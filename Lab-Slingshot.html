<!-- I AM VERY SORRY FOR THIS TERRIBLE AND IMPOSSIBLE TO UNDERSTAND CODE -->
<!DOCTYPE html>
<head>
    <title>Slingshot calculator</title>
    <style>
        button {
            width: 100%;
        }
    </style>
</head>
<body>
    <ul>
        <li>Board launch math (board length, board height, board raise, slingshot height)</li>
        <li>Dmax: <span id="dmax"></span> m</li>
        <li>Time</li>
    </ul>
    <table>
        <tr>
            <td>Launch velocity (m/s)</td>
            <td><input type="number" id="v0"></td>
        </tr>
        <tr>
            <td>Launch angle (in degree)</td>
            <td><input type="number" id="theta"></td>
        </tr>
        <tr>
            <td>Target distance (in m)</td>
            <td><input type="number" id="d1x"></td>
        </tr>
        <tr>
            <td>Target height (in m)</td>
            <td><input type="number" id="d1y"></td>
        </tr>
        <tr>
            <td colspan="2">
                <button onclick="runResult()">Update graph</button>
            </td>
        </tr>
    </table>
    <canvas id="canvas" width="1000", height="600"></canvas>
    <p>Each dot represents 0.01 seconds (10 ms) interval. The green line is dmax, the red line is the target.</p>
</body>
<script>
    const GA = -9.8067, // gravitational acceleration HAVE NEGATIVE
        baseHeight = 0.087; // the height of the base of the platform

    // programming const
    const CANVAS = document.getElementById('canvas').getContext('2d'),
        V0_INP = document.getElementById('v0'),
        D1X_INP = document.getElementById('d1x'),
        D1Y_INP = document.getElementById('d1y'),
        THETA_INP = document.getElementById('theta'),
        DMAX_OUT = document.getElementById('dmax');
    CANVAS.width = document.getElementById('canvas').width;
    CANVAS.height = document.getElementById('canvas').height;

    const SCALE_FACTORX = 100; // scale factor to determine 1 m = how many pixel
    const SCALE_FACTORY = -100; // scale factor negative to flip the graph
    CANVAS.translate(0, CANVAS.height); // translate the graph according to the height of the canvas
    const {PI, abs, sin, cos, sqrt, max, min, floor} = Math;

    // global value
    let v0 = 0, theta = 0;
        theta = theta * PI / 180; // convert theta to Radian
    let v0x = 0, v0y = 0; // vector decontruction
    function parseInp() {
        v0 = parseFloat(V0_INP.value);
        theta = parseFloat(THETA_INP.value); theta = theta * PI / 180; // convert theta to Radian
        v0x = v0 * cos(theta);
        v0y = v0 * sin(theta); // vector decontruction
    }

    function drawCircle(x, y, rad = 1) {
        if (rad != 1) CANVAS.strokeStyle = "#FF0000"; // special circle
        CANVAS.beginPath(); // start to draw
        CANVAS.arc(x * SCALE_FACTORX, y * SCALE_FACTORY, rad, 0, 2 * PI);
        CANVAS.stroke(); // render the path
        // reset stroke style
        CANVAS.strokeStyle = '#000000';
    }

    function drawGrid() {
        // I have no idea how these "magic numbers" work
        CANVAS.strokeStyle = "#000000";
        CANVAS.beginPath(); // start to draw
        for (
            let l1 = 0; 
            l1 * SCALE_FACTORX <= CANVAS.width; // Stop when width out-of-frame
            l1++
        ) {
            CANVAS.moveTo(l1 * SCALE_FACTORX, 0);
            CANVAS.lineTo(l1 * SCALE_FACTORX, -CANVAS.height);
            CANVAS.moveTo(0, l1 * SCALE_FACTORY);
            CANVAS.lineTo(CANVAS.width, l1 * SCALE_FACTORY);
        }
        CANVAS.stroke(); // render the path
    }

    function runResult() {
        // check if user want to update graph
        parseInp()
        if (V0_INP.value && THETA_INP.value) {
            // all are ready
            updateGraph();
        }
        if (!D1X_INP.value || !D1Y_INP.value) return; // must have dx1 to continue
        if (!V0_INP.value && THETA_INP.value) {
            // find v0 from theta
            let minMiss = Infinity, minMissV0 = 0;
            let targetDy = D1Y_INP.value;
            for (
                V0_INP.value = 1;
                V0_INP.value < 50;
                V0_INP.value = parseFloat(V0_INP.value) + 0.1
            ) {
                updateGraph();
                let amiss = abs(targetDy - D1Y_INP.value)
                if (amiss < minMiss) {
                    minMiss = amiss;
                    minMissV0 = v0;
                }
            }
            V0_INP.value = minMissV0;
            updateGraph()
        } else if (V0_INP.value && !THETA_INP.value) {
            let minMiss = Infinity, minMissTheta = 0;
            let targetDy = D1Y_INP.value;
            for (
                THETA_INP.value = 0; 
                THETA_INP.value < 90; 
                THETA_INP.value = parseFloat(THETA_INP.value) + 0.1
            ) {
                // trial and error
                updateGraph();
                let amiss = abs(targetDy - D1Y_INP.value)
                if (amiss < minMiss) {
                    minMiss = amiss;
                    minMissTheta = theta;
                }
            }
            THETA_INP.value = minMissTheta * 180/PI;
            updateGraph()
        }
    }

    function updateGraph() {
        // clear graph
        CANVAS.clearRect(0, 0, CANVAS.width * SCALE_FACTORX, CANVAS.height * SCALE_FACTORY);

        parseInp();
        // loop through t to get d1
        let dyMax = 0;
        for (let t = 0; t < 100; t += 0.01) {
            let dx = v0x * t,
                dy = v0y * t + 0.5 * GA * t*t;
            if (dy > dyMax) dyMax = dy;
            drawCircle(dx, dy);
            if (dy < 0) break;
        }
        // dmax
        CANVAS.strokeStyle = "#00FF00";
        CANVAS.beginPath();
        CANVAS.moveTo(0, dyMax * SCALE_FACTORY);
        CANVAS.lineTo(CANVAS.width, dyMax * SCALE_FACTORY);
        CANVAS.stroke();
        DMAX_OUT.innerHTML = dyMax.toFixed(3);
        // update target
        CANVAS.strokeStyle = "#FF0000";
        CANVAS.beginPath();
        CANVAS.moveTo(D1X_INP.value * SCALE_FACTORX, 0);
        CANVAS.lineTo(D1X_INP.value * SCALE_FACTORX, -CANVAS.height);
        {
            // calculate the target hit
            let dx1 = D1X_INP.value;
            let t = dx1 / v0x;
            let dy = v0y * t + 0.5 * GA * t*t;
            CANVAS.moveTo(0, dy * SCALE_FACTORY);
            CANVAS.lineTo(CANVAS.width, dy * SCALE_FACTORY);
            D1Y_INP.value = dy;
        }
        CANVAS.stroke();
        // update display
        drawGrid()
    }

    // repeat for the loading screen
    let loadingV0 = 5, loadingTheta = 45;
    let loadingInterval = setInterval(() => {
        V0_INP.value = (loadingV0 % 15).toFixed(2); THETA_INP.value = loadingTheta % 90;
        loadingV0 += 0.1; loadingTheta++
        runResult()
    }, 100);

    document.onclick = () => {
        clearInterval(loadingInterval)
    }
</script>